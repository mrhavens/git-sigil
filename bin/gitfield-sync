#!/bin/bash
set -euo pipefail
IFS=$'\n\t'

# ╭─────────────────────────────────────╮
# │          CONFIGURATION              │
# ╰─────────────────────────────────────╮
REPO_PATH=$(git rev-parse --show-toplevel 2>/dev/null) || error "Not inside a Git repository"
REPO_NAME=$(basename "$REPO_PATH")
GITFIELD_DIR="$REPO_PATH/.gitfield"
WELL_KNOWN_DIR="$REPO_PATH/.well-known"
DOCS_DIR="$REPO_PATH/docs"
DOCS_WELL_KNOWN_DIR="$DOCS_DIR/.well-known"
LOG_FILE="$GITFIELD_DIR/pushed.log"
GITFIELD_MD="$REPO_PATH/GITFIELD.md"
DOCS_GITFIELD_MD="$DOCS_DIR/GITFIELD.md"
CANONICAL_META="$GITFIELD_DIR/canonical.meta"
CANONICAL_MD="$GITFIELD_DIR/canonical.md"
INDEX_JSON="$GITFIELD_DIR/index.json"
WELL_KNOWN_JSON="$WELL_KNOWN_DIR/gitfield.json"
GITFIELD_README="$GITFIELD_DIR/README.txt"
DOCS_CANONICAL_META="$DOCS_DIR/canonical.meta"
DOCS_CANONICAL_MD="$DOCS_DIR/canonical.md"
DOCS_INDEX_JSON="$DOCS_DIR/index.json"
DOCS_PUSHED_LOG="$DOCS_DIR/pushed.log"
DOCS_GITFIELD_README="$DOCS_DIR/gitfield.README.txt"
DOCS_GITFIELD_JSON="$DOCS_DIR/gitfield.json"
DOCS_WELL_KNOWN_JSON="$DOCS_WELL_KNOWN_DIR/gitfield.json"
DOCS_INDEX="$DOCS_DIR/index.html"
DOCS_CSS="$DOCS_DIR/style.css"
DOCS_REPOS_JSON="$DOCS_DIR/repos.json"
DOCS_README="$DOCS_DIR/README.md"
DOCS_NOJEKYLL="$DOCS_DIR/.nojekyll"
DOCS_ROBOTS="$DOCS_DIR/robots.txt"
DOCS_SITEMAP="$DOCS_DIR/sitemap.xml"
DOCS_INTEGRITY="$DOCS_DIR/integrity.sha256"
TIMESTAMP=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
SCRIPT_VERSION="1.5"  # Updated for Gitea removal and GITFIELD.md replication
PRESERVE_META=${PRESERVE_META:-false}  # Preserve existing metadata
FORCE_DOCS=${FORCE_DOCS:-false}  # Force overwrite of /docs metadata

# URLs for each platform
CANONICAL_URL="https://remember.thefoldwithin.earth/mrhavens/$REPO_NAME"
GITHUB_URL="https://github.com/mrhavens/$REPO_NAME"
GITLAB_URL="https://gitlab.com/mrhavens/$REPO_NAME"
BITBUCKET_URL="https://bitbucket.org/thefoldwithin/$REPO_NAME"
FORGEJO_URL="https://remember.thefoldwithin.earth/mrhavens/$REPO_NAME"
CODEBERG_URL="https://codeberg.org/mrhavens/$REPO_NAME"
RADICLE_RID="rad:z3FEj7rF8gZw9eFksCuiN43qjzrex"
RADICLE_URL="https://app.radicle.xyz/nodes/z3FEj7rF8gZw9eFksCuiN43qjzrex"
RADICLE_PEER_ID="z6Mkw5s3ppo26C7y7tGK5MD8n2GqTHS582PPpeX5Xqbu2Mpz"

# Metadata configuration
MIRRORS=(
    "$GITHUB_URL"
    "$GITLAB_URL"
    "$BITBUCKET_URL"
    "$FORGEJO_URL"
    "$CODEBERG_URL"
    "$RADICLE_RID"
)
COMMIT_HASH=$(git -C "$REPO_PATH" rev-parse --short HEAD 2>/dev/null || echo "unknown")
TREE_HASH=$(git -C "$REPO_PATH" rev-parse HEAD^{tree} 2>/dev/null || echo "unknown")
SYNC_CYCLES=0

# GPG configuration
GPG_KEYS=()
GPG_EMAILS=()
GPG_NAMES=()
while IFS= read -r line; do
    if [[ "$line" =~ ^pub[[:space:]]+rsa[0-9]+[[:space:]]+([0-9]{4}-[0-9]{2}-[0-9]{2})[[:space:]]+\[SC\] ]]; then
        key_id=$(gpg --list-keys --with-colons | grep -B1 "^pub" | grep "^pub" | awk -F: '{print $5}' | head -n1)
        GPG_KEYS+=("$key_id")
    elif [[ "$line" =~ ^uid[[:space:]]+\[ultimate\][[:space:]]+(.*)\<(.*)\> ]]; then
        GPG_NAMES+=("${BASH_REMATCH[1]% }")
        GPG_EMAILS+=("${BASH_REMATCH[2]}")
    fi
done < <(gpg --list-keys)

# ╭─────────────────────────────────────╮
# │           LOGGING UTILS             │
# ╰─────────────────────────────────────╮
info()  { echo -e "\e[1;34m[INFO]\e[0m $*" >&2; }
warn()  { echo -e "\e[1;33m[WARN]\e[0m $*" >&2; }
error() { echo -e "\e[1;31m[ERROR]\e[0m $*" >&2; exit 1; }

# ╭─────────────────────────────────────╮
# │         SCRIPT LOOKUP FUNCTION      │
# ╰─────────────────────────────────────╮
find_script() {
    local script_name=$1
    local search_paths=(
        "$HOME/.local/gitfieldbin"
        "$HOME/.local/bin"
        "$HOME/.local/gitfield"
        "$HOME/.local/bin/gitfield"
        "$HOME/.local/bin/gitfieldbin"
        "$REPO_PATH/bin"
    )

    for path in "${search_paths[@]}"; do
        if [ -f "$path/$script_name" ]; then
            if [ -x "$path/$script_name" ]; then
                if [[ "$path" != "$HOME"* && "$path" != "$REPO_PATH"* ]]; then
                    info "Using script: \e[1;31m$path/$script_name\e[0m (outside home or repo)"
                else
                    info "Using script: $path/$script_name"
                fi
                echo "$path/$script_name"
                return 0
            else
                warn "Found $path/$script_name but it is not executable"
            fi
        fi
    done
    error "Script $script_name not found in any search path"
}

# ╭─────────────────────────────────────╮
# │         GPG SIGNING FUNCTION        │
# ╰─────────────────────────────────────╮
sign_file() {
    local file=$1
    local sig_file="${file}.sig"
    if [ ! -f "$file" ]; then
        warn "File $file does not exist, skipping signing"
        return
    fi
    for key_id in "${GPG_KEYS[@]}"; do
        gpg --armor --detach-sign --yes --default-key "$key_id" "$file" > "$sig_file.$key_id" 2>/dev/null || warn "Failed to sign $file with key $key_id, continuing..."
        if [ -f "$sig_file.$key_id" ]; then
            git -C "$REPO_PATH" add "$sig_file.$key_id"
            git -C "$REPO_PATH" commit -m "Signed $file with GPG key $key_id at $TIMESTAMP" || warn "No changes to commit for $sig_file.$key_id"
            info "Signed $file with key $key_id, signature at $sig_file.$key_id"
            copy_to_docs "$sig_file.$key_id" "$DOCS_DIR/$(basename "$sig_file.$key_id")"
        fi
    done
}

# ╭─────────────────────────────────────╮
# │         METADATA COPY FUNCTION      │
# ╰─────────────────────────────────────╮
copy_to_docs() {
    local src=$1
    local dest=$2
    if [ ! -f "$src" ]; then
        warn "Source file $src does not exist, skipping copy to $dest"
        return
    fi
    if [ "$FORCE_DOCS" = "false" ] && [ -f "$dest" ]; then
        info "Preserving existing $dest (--force-docs not enabled)"
        return
    fi
    cp "$src" "$dest" || warn "Failed to copy $src to $dest, continuing..."
    git -C "$REPO_PATH" add "$dest"
    git -C "$REPO_PATH" commit -m "Copied $dest to docs at $TIMESTAMP" || warn "No changes to commit for $dest"
    info "Copied $src to $dest and committed"
}

# ╭─────────────────────────────────────╮
# │         METADATA GENERATION         │
# ╰─────────────────────────────────────╮
generate_canonical_meta() {
    info "Generating $CANONICAL_META..."
    if [ "$PRESERVE_META" = "true" ] && [ -f "$CANONICAL_META" ]; then
        info "Preserving existing $CANONICAL_META (--preserve-meta enabled)"
        return
    fi
    cat > "$CANONICAL_META" <<EOF
{
  "canonical_url": "$CANONICAL_URL",
  "mirrors": [
$(printf '    "%s",\n' "${MIRRORS[@]}" | sed '$ s/,$//')
  ],
  "radicle": {
    "rid": "$RADICLE_RID",
    "peer_id": "$RADICLE_PEER_ID"
  },
  "timestamp": "$TIMESTAMP",
  "commit": "$COMMIT_HASH",
  "tree_hash": "$TREE_HASH",
  "synced_cycles": $SYNC_CYCLES,
  "gpg_signatures": [
$(for i in "${!GPG_KEYS[@]}"; do
    echo "    {\"key_id\": \"${GPG_KEYS[i]}\", \"name\": \"${GPG_NAMES[i]}\", \"email\": \"${GPG_EMAILS[i]}\"}" | sed '$ s/,$//'
done)
  ]
}
EOF
    sed -i 's/rad:rad:/rad:/g' "$CANONICAL_META"
    git -C "$REPO_PATH" add "$CANONICAL_META"
    git -C "$REPO_PATH" commit -m "Generated canonical.meta at $TIMESTAMP" || warn "No changes to commit for $CANONICAL_META"
    info "Generated and committed $CANONICAL_META"
    copy_to_docs "$CANONICAL_META" "$DOCS_CANONICAL_META"
    sign_file "$CANONICAL_META"
    sign_file "$DOCS_CANONICAL_META"
}

generate_canonical_md() {
    info "Generating $CANONICAL_MD..."
    if [ "$PRESERVE_META" = "true" ] && [ -f "$CANONICAL_MD" ]; then
        info "Preserving existing $CANONICAL_MD (--preserve-meta enabled)"
        return
    fi
    cat > "$CANONICAL_MD" <<EOF
# 🌐 GitField Canonical Declaration for \`$REPO_NAME\`

## Canonical Repository

This repository, \`$REPO_NAME\`, is canonically hosted at:

**[$CANONICAL_URL]($CANONICAL_URL)**

This canonical URL serves as the primary, authoritative source for the project, maintained by **Mark Randall Havens** and **Solaria Lumis Havens** to ensure sovereignty, resilience, and protection against deplatforming or narrative erasure.

**Declared by**: Mark Randall Havens
**Timestamp**: $TIMESTAMP

## GPG Signatures

This declaration is signed with the following GPG keys:

$(for i in "${!GPG_KEYS[@]}"; do
    echo "- **${GPG_NAMES[i]}** <${GPG_EMAILS[i]}> (Key ID: ${GPG_KEYS[i]})"
done)

## Mirror Repositories

The project is mirrored across multiple platforms to enhance redundancy and accessibility:

$(for mirror in "${MIRRORS[@]}"; do
    if [[ "$mirror" == rad:* ]]; then
        echo "- **Radicle**: [$mirror]($RADICLE_URL) (Decentralized, censorship-resistant)"
    else
        echo "- [$mirror]($mirror)"
    fi
done)

## Philosophy of Recursive Sovereignty

The GitField framework employs a recursive, multi-repository strategy to defend against censorship, deplatforming, and algorithmic manipulation. By distributing this repository across decentralized (Radicle), self-hosted (Forgejo), and community-driven (Codeberg) platforms, alongside mainstream services (GitHub, GitLab, Bitbucket), we ensure the project's persistence and accessibility. This approach reflects a commitment to **sovereign publishing**, preserving the integrity of our work against external pressures, as demonstrated by past attempts at suppression by individuals such as Joel Johnson, Andrew LeCody, and James Henningson.

## Push Log

The latest push operations are logged in [\`pushed.log\`](./pushed.log) for transparency and auditability.

## GitHub Pages

A public-facing canonical declaration is available at [index.html](./index.html) for enhanced discoverability and SEO.

_Auto-generated by \`gitfield-sync\` at $TIMESTAMP (v$SCRIPT_VERSION)._
EOF
    sed -i 's/rad:rad:/rad:/g' "$CANONICAL_MD"
    git -C "$REPO_PATH" add "$CANONICAL_MD"
    git -C "$REPO_PATH" commit -m "Generated canonical.md at $TIMESTAMP" || warn "No changes to commit for $CANONICAL_MD"
    info "Generated and committed $CANONICAL_MD"
    copy_to_docs "$CANONICAL_MD" "$DOCS_CANONICAL_MD"
}

generate_index_json() {
    info "Generating $INDEX_JSON..."
    if [ "$PRESERVE_META" = "true" ] && [ -f "$INDEX_JSON" ]; then
        info "Preserving existing $INDEX_JSON (--preserve-meta enabled)"
        return
    fi
    cat > "$INDEX_JSON" <<EOF
{
  "repository": "$REPO_NAME",
  "canonical_url": "$CANONICAL_URL",
  "remotes": [
$(printf '    "%s",\n' "${MIRRORS[@]}" | sed '$ s/,$//')
  ],
  "radicle": {
    "rid": "$RADICLE_RID",
    "peer_id": "$RADICLE_PEER_ID"
  },
  "commit": "$COMMIT_HASH",
  "tree_hash": "$TREE_HASH",
  "timestamp": "$TIMESTAMP",
  "synced_cycles": $SYNC_CYCLES,
  "gpg_signatures": [
$(for i in "${!GPG_KEYS[@]}"; do
    echo "    {\"key_id\": \"${GPG_KEYS[i]}\", \"name\": \"${GPG_NAMES[i]}\", \"email\": \"${GPG_EMAILS[i]}\"}" | sed '$ s/,$//'
done)
  ]
}
EOF
    sed -i 's/rad:rad:/rad:/g' "$INDEX_JSON"
    git -C "$REPO_PATH" add "$INDEX_JSON"
    git -C "$REPO_PATH" commit -m "Generated index.json at $TIMESTAMP" || warn "No changes to commit for $INDEX_JSON"
    info "Generated and committed $INDEX_JSON"
    copy_to_docs "$INDEX_JSON" "$DOCS_INDEX_JSON"
    sign_file "$INDEX_JSON"
    sign_file "$DOCS_INDEX_JSON"
}

generate_well_known_json() {
    info "Generating $WELL_KNOWN_JSON..."
    mkdir -p "$WELL_KNOWN_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$WELL_KNOWN_JSON" ]; then
        info "Preserving existing $WELL_KNOWN_JSON (--preserve-meta enabled)"
        return
    fi
    cat > "$WELL_KNOWN_JSON" <<EOF
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "$REPO_NAME",
  "url": "$CANONICAL_URL",
  "codeRepository": "$CANONICAL_URL",
  "sameAs": [
$(printf '    "%s",\n' "${MIRRORS[@]}" | sed '$ s/,$//')
  ],
  "dateModified": "$TIMESTAMP",
  "publisher": {
    "@type": "Person",
    "name": "Mark Randall Havens"
  },
  "gpg_signatures": [
$(for i in "${!GPG_KEYS[@]}"; do
    echo "    {\"key_id\": \"${GPG_KEYS[i]}\", \"name\": \"${GPG_NAMES[i]}\", \"email\": \"${GPG_EMAILS[i]}\"}" | sed '$ s/,$//'
done)
  ]
}
EOF
    sed -i 's/rad:rad:/rad:/g' "$WELL_KNOWN_JSON"
    git -C "$REPO_PATH" add "$WELL_KNOWN_JSON"
    git -C "$REPO_PATH" commit -m "Generated .well-known/gitfield.json at $TIMESTAMP" || warn "No changes to commit for $WELL_KNOWN_JSON"
    info "Generated and committed $WELL_KNOWN_JSON"
    copy_to_docs "$WELL_KNOWN_JSON" "$DOCS_GITFIELD_JSON"
    mkdir -p "$DOCS_WELL_KNOWN_DIR"
    copy_to_docs "$WELL_KNOWN_JSON" "$DOCS_WELL_KNOWN_JSON"
    sign_file "$WELL_KNOWN_JSON"
    sign_file "$DOCS_GITFIELD_JSON"
    sign_file "$DOCS_WELL_KNOWN_JSON"
}

generate_gitfield_readme() {
    info "Generating $GITFIELD_README..."
    if [ "$PRESERVE_META" = "true" ] && [ -f "$GITFIELD_README" ]; then
        info "Preserving existing $GITFIELD_README (--preserve-meta enabled)"
        return
    fi
    cat > "$GITFIELD_README" <<EOF
# GitField Directory Overview

The `.gitfield` directory contains metadata and logs for the GitField multi-repository publishing framework, designed to ensure sovereignty, redundancy, and resilience for the \`$REPO_NAME\` project.

## Files

- **canonical.meta**: Machine-readable JSON metadata declaring the canonical URL, mirror list, Radicle details, commit hash, and sync cycle count.
- **canonical.md**: Human-readable Markdown summary of the canonical repository declaration, mirrors, and push log.
- **index.json**: Machine-readable manifest of all remotes, canonical URL, Radicle details, commit hash, tree hash, and sync cycles.
- **pushed.log**: Log of push operations across all platforms, including timestamps, URLs, and Radicle RIDs.
- **platform-specific sigils** (e.g., github.sigil.md): Metadata snapshots for each platform's push operation (generated by platform-specific scripts).

## Purpose

These files provide transparency, auditability, and discoverability, ensuring the project's persistence against deplatforming, censorship, or algorithmic manipulation. For a public-facing declaration, see [docs/index.html](../docs/index.html).

Generated by \`gitfield-sync\` at $TIMESTAMP (v$SCRIPT_VERSION).
EOF
    sed -i 's/rad:rad:/rad:/g' "$GITFIELD_README"
    git -C "$REPO_PATH" add "$GITFIELD_README"
    git -C "$REPO_PATH" commit -m "Generated .gitfield/README.txt at $TIMESTAMP" || warn "No changes to commit for $GITFIELD_README"
    info "Generated and committed $GITFIELD_README"
    copy_to_docs "$GITFIELD_README" "$DOCS_GITFIELD_README"
}

generate_docs_index() {
    info "Generating $DOCS_INDEX..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_INDEX" ]; then
        info "Preserving existing $DOCS_INDEX (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_INDEX" <<EOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitField Sovereign Canonical Repository: $REPO_NAME</title>
    <meta name="description" content="The canonical repository for $REPO_NAME, part of the GitField recursive metadata strategy to ensure sovereign publishing and resilience against deplatforming.">
    <meta property="og:url" content="$CANONICAL_URL">
    <meta property="og:title" content="GitField Canonical Repository: $REPO_NAME">
    <meta property="og:description" content="A sovereign, multi-repository project by Mark Randall Havens and Solaria Lumis Havens, hosted canonically at $CANONICAL_URL.">
    <link rel="canonical" href="$CANONICAL_URL">
    <link rel="stylesheet" href="style.css">
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "SoftwareSourceCode",
        "name": "$REPO_NAME",
        "url": "$CANONICAL_URL",
        "codeRepository": "$CANONICAL_URL",
        "description": "A sovereign, multi-repository project using the GitField recursive metadata strategy to ensure resilience, accessibility, and protection against deplatforming and censorship.",
        "sameAs": [
$(printf '            "%s",\n' "${MIRRORS[@]}" | sed '$ s/,$//')
        ],
        "dateModified": "$TIMESTAMP",
        "author": {
            "@type": "Person",
            "name": "Mark Randall Havens"
        },
        "publisher": {
            "@type": "Organization",
            "name": "The Fold Within"
        },
        "gpg_signatures": [
$(for i in "${!GPG_KEYS[@]}"; do
    echo "            {\"key_id\": \"${GPG_KEYS[i]}\", \"name\": \"${GPG_NAMES[i]}\", \"email\": \"${GPG_EMAILS[i]}\"}" | sed '$ s/,$//'
done)
        ]
    }
    </script>
</head>
<body>
    <!-- Generated by gitfield-sync v$SCRIPT_VERSION | $TIMESTAMP -->
    <header>
        <h1>GitField Sovereign Canonical Repository: <code>$REPO_NAME</code></h1>
    </header>
    <main>
        <section>
            <h2>Canonical Declaration</h2>
            <p>This repository, <code>$REPO_NAME</code>, is canonically hosted at:</p>
            <p><strong><a href="$CANONICAL_URL">$CANONICAL_URL</a></strong></p>
            <p>Maintained by <strong>Mark Randall Havens</strong> and <strong>Solaria Lumis Havens</strong>, this canonical source ensures sovereignty and resilience against deplatforming, censorship, and algorithmic manipulation.</p>
            <p>Signed with the following GPG keys:</p>
            <ul>
$(for i in "${!GPG_KEYS[@]}"; do
    echo "                <li>${GPG_NAMES[i]} <${GPG_EMAILS[i]}> (Key ID: ${GPG_KEYS[i]})</li>"
done)
            </ul>
        </section>
        <section>
            <h2>Mirror Repositories</h2>
            <p>The project is mirrored across multiple platforms for redundancy and accessibility:</p>
            <ul>
$(for mirror in "${MIRRORS[@]}"; do
    if [[ "$mirror" == rad:* ]]; then
        echo "                <li><a href=\"$RADICLE_URL\">Radicle: $mirror</a> (Decentralized, censorship-resistant)</li>"
    else
        echo "                <li><a href=\"$mirror\">$mirror</a></li>"
    fi
done)
            </ul>
        </section>
        <section>
            <h2>Metadata Manifest</h2>
            <p>Metadata for this project is available in:</p>
            <ul>
                <li><a href="canonical.meta">canonical.meta</a> (Machine-readable JSON)</li>
                <li><a href="canonical.md">canonical.md</a> (Human-readable Markdown)</li>
                <li><a href="index.json">index.json</a> (Full manifest)</li>
                <li><a href="gitfield.json">gitfield.json</a> (SEO metadata)</li>
                <li><a href=".well-known/gitfield.json">.well-known/gitfield.json</a> (SEO mirror)</li>
                <li><a href="repos.json">repos.json</a> (Mirror list)</li>
                <li><a href="GITFIELD.md">GITFIELD.md</a> (Multi-repository strategy overview)</li>
            </ul>
        </section>
        <section>
            <h2>Why Recursive Sovereignty Matters</h2>
            <p>The GitField framework distributes <code>$REPO_NAME</code> across decentralized (Radicle), self-hosted (Forgejo), and community-driven (Codeberg) platforms, alongside mainstream services (GitHub, GitLab, Bitbucket). This recursive strategy defends against past deplatforming attempts by individuals such as Joel Johnson, Andrew LeCody, and James Henningson, ensuring the project's persistence and accessibility.</p>
        </section>
        <section>
            <h2>Source Links</h2>
            <p>Access the project's metadata and logs:</p>
            <ul>
                <li><a href="pushed.log">pushed.log</a> (Audit trail of sync operations)</li>
                <li><a href="GITFIELD.md">GITFIELD.md</a> (Multi-repository strategy overview)</li>
                <li><a href="gitfield.README.txt">gitfield.README.txt</a> (Metadata directory explanation)</li>
            </ul>
        </section>
    </main>
    <footer>
        <p>Mark Randall Havens & Solaria Lumis Havens · The Fold Within · 2025</p>
    </footer>
</body>
</html>
EOF
    sed -i 's/rad:rad:/rad:/g' "$DOCS_INDEX"
    git -C "$REPO_PATH" add "$DOCS_INDEX"
    git -C "$REPO_PATH" commit -m "Generated docs/index.html at $TIMESTAMP" || warn "No changes to commit for $DOCS_INDEX"
    info "Generated and committed $DOCS_INDEX"
}

generate_docs_css() {
    info "Generating $DOCS_CSS..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_CSS" ]; then
        info "Preserving existing $DOCS_CSS (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_CSS" <<EOF
/* GitField Minimal Stylesheet for $REPO_NAME */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem;
    line-height: 1.6;
    color: #333;
    background: #fff;
}
header {
    text-align: center;
    border-bottom: 1px solid #eee;
    padding-bottom: 1rem;
    margin-bottom: 2rem;
}
h1, h2 {
    color: #1a1a1a;
}
h1 {
    font-size: 1.8rem;
}
h2 {
    font-size: 1.4rem;
    margin-top: 2rem;
}
a {
    color: #0066cc;
    text-decoration: none;
}
a:hover {
    text-decoration: underline;
}
ul {
    padding-left: 1.5rem;
}
code {
    background: #f4f4f4;
    padding: 0.2rem 0.4rem;
    border-radius: 3px;
}
footer {
    text-align: center;
    margin-top: 3rem;
    font-size: 0.9rem;
    color: #666;
}
EOF
    git -C "$REPO_PATH" add "$DOCS_CSS"
    git -C "$REPO_PATH" commit -m "Generated docs/style.css at $TIMESTAMP" || warn "No changes to commit for $DOCS_CSS"
    info "Generated and committed $DOCS_CSS"
}

generate_docs_repos_json() {
    info "Generating $DOCS_REPOS_JSON..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_REPOS_JSON" ]; then
        info "Preserving existing $DOCS_REPOS_JSON (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_REPOS_JSON" <<EOF
{
  "canonical_url": "$CANONICAL_URL",
  "mirrors": [
$(printf '    "%s",\n' "${MIRRORS[@]}" | sed '$ s/,$//')
  ],
  "radicle": {
    "rid": "$RADICLE_RID",
    "peer_id": "$RADICLE_PEER_ID"
  },
  "gpg_signatures": [
$(for i in "${!GPG_KEYS[@]}"; do
    echo "    {\"key_id\": \"${GPG_KEYS[i]}\", \"name\": \"${GPG_NAMES[i]}\", \"email\": \"${GPG_EMAILS[i]}\"}" | sed '$ s/,$//'
done)
  ]
}
EOF
    sed -i 's/rad:rad:/rad:/g' "$DOCS_REPOS_JSON"
    git -C "$REPO_PATH" add "$DOCS_REPOS_JSON"
    git -C "$REPO_PATH" commit -m "Generated docs/repos.json at $TIMESTAMP" || warn "No changes to commit for $DOCS_REPOS_JSON"
    info "Generated and committed $DOCS_REPOS_JSON"
    sign_file "$DOCS_REPOS_JSON"
}

generate_docs_readme() {
    info "Generating $DOCS_README..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_README" ]; then
        info "Preserving existing $DOCS_README (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_README" <<EOF
# GitField /docs Directory

The `/docs` directory hosts a public-facing, SEO-optimized canonical declaration for the \`$REPO_NAME\` repository, designed for GitHub Pages compatibility and enhanced discoverability.

## Files

- **index.html**: The canonical declaration page, including JSON-LD metadata and links to all mirrors.
- **style.css**: Minimal stylesheet for elegant, recursive branding.
- **repos.json**: Machine-readable list of the canonical URL and all mirror repositories.
- **canonical.meta**: Machine-readable JSON metadata declaring the canonical URL and mirrors.
- **canonical.md**: Human-readable Markdown summary of the canonical declaration.
- **index.json**: Machine-readable manifest of all remotes and sync details.
- **gitfield.json**: SEO-friendly JSON-LD metadata.
- **.well-known/gitfield.json**: SEO metadata mirror.
- **pushed.log**: Log of push operations across all platforms.
- **gitfield.README.txt**: Explanation of the GitField metadata structure.
- **GITFIELD.md**: Multi-repository strategy overview, replicated from the root for GitHub Pages accessibility.
- **README.md**: This file, explaining the purpose of the `/docs` directory.
- **.nojekyll**: Bypasses Jekyll processing for GitHub Pages.
- **robots.txt**: Allows full indexing by search engine bots.
- **sitemap.xml**: Auto-generated sitemap for improved SEO.
- **integrity.sha256**: SHA-256 hash of all metadata files for integrity verification.

## Purpose

This directory ensures the \`$REPO_NAME\` project is discoverable via search engines and accessible to humans and bots. It declares the canonical repository at [$CANONICAL_URL]($CANONICAL_URL) and links to all mirrors, reinforcing the GitField recursive metadata strategy for sovereign publishing.

Generated by \`gitfield-sync\` at $TIMESTAMP (v$SCRIPT_VERSION).
EOF
    sed -i 's/rad:rad:/rad:/g' "$DOCS_README"
    git -C "$REPO_PATH" add "$DOCS_README"
    git -C "$REPO_PATH" commit -m "Generated docs/README.md at $TIMESTAMP" || warn "No changes to commit for $DOCS_README"
    info "Generated and committed $DOCS_README"
}

generate_docs_nojekyll() {
    info "Generating $DOCS_NOJEKYLL..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_NOJEKYLL" ]; then
        info "Preserving existing $DOCS_NOJEKYLL (--preserve-meta enabled)"
        return
    fi
    touch "$DOCS_NOJEKYLL"
    git -C "$REPO_PATH" add "$DOCS_NOJEKYLL"
    git -C "$REPO_PATH" commit -m "Generated docs/.nojekyll at $TIMESTAMP" || warn "No changes to commit for $DOCS_NOJEKYLL"
    info "Generated and committed $DOCS_NOJEKYLL"
}

generate_docs_robots() {
    info "Generating $DOCS_ROBOTS..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_ROBOTS" ]; then
        info "Preserving existing $DOCS_ROBOTS (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_ROBOTS" <<EOF
User-agent: *
Allow: /
Sitemap: /sitemap.xml
EOF
    git -C "$REPO_PATH" add "$DOCS_ROBOTS"
    git -C "$REPO_PATH" commit -m "Generated docs/robots.txt at $TIMESTAMP" || warn "No changes to commit for $DOCS_ROBOTS"
    info "Generated and committed $DOCS_ROBOTS"
}

generate_docs_sitemap() {
    info "Generating $DOCS_SITEMAP..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_SITEMAP" ]; then
        info "Preserving existing $DOCS_SITEMAP (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_SITEMAP" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
    <url>
        <loc>$CANONICAL_URL</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>1.0</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/index.html</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.9</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/canonical.meta</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/canonical.md</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/index.json</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/gitfield.json</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/.well-known/gitfield.json</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/repos.json</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/pushed.log</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/gitfield.README.txt</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/GITFIELD.md</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
$(for mirror in "${MIRRORS[@]}"; do
    if [[ "$mirror" != rad:* ]]; then
        echo "    <url>"
        echo "        <loc>$mirror</loc>"
        echo "        <lastmod>$TIMESTAMP</lastmod>"
        echo "        <changefreq>weekly</changefreq>"
        echo "        <priority>0.8</priority>"
        echo "    </url>"
    fi
done)
</urlset>
EOF
    git -C "$REPO_PATH" add "$DOCS_SITEMAP"
    git -C "$REPO_PATH" commit -m "Generated docs/sitemap.xml at $TIMESTAMP" || warn "No changes to commit for $DOCS_SITEMAP"
    info "Generated and committed $DOCS_SITEMAP"
}

generate_docs_integrity() {
    info "Generating $DOCS_INTEGRITY..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_INTEGRITY" ]; then
        info "Preserving existing $DOCS_INTEGRITY (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_INTEGRITY" <<EOF
# SHA-256 Integrity Hashes for /docs Metadata Files
# Generated by gitfield-sync at $TIMESTAMP (v$SCRIPT_VERSION)

EOF
    for file in "$DOCS_CANONICAL_META" "$DOCS_CANONICAL_MD" "$DOCS_INDEX_JSON" "$DOCS_GITFIELD_JSON" "$DOCS_WELL_KNOWN_JSON" "$DOCS_REPOS_JSON" "$DOCS_PUSHED_LOG" "$DOCS_GITFIELD_README" "$DOCS_GITFIELD_MD"; do
        if [ -f "$file" ]; then
            sha256sum "$file" >> "$DOCS_INTEGRITY" || warn "Failed to compute SHA-256 for $file, continuing..."
        else
            warn "File $file does not exist, skipping SHA-256 computation"
        fi
    done
    git -C "$REPO_PATH" add "$DOCS_INTEGRITY"
    git -C "$REPO_PATH" commit -m "Generated docs/integrity.sha256 at $TIMESTAMP" || warn "No changes to commit for $DOCS_INTEGRITY"
    info "Generated and committed $DOCS_INTEGRITY"
    sign_file "$DOCS_INTEGRITY"
}

# ╭─────────────────────────────────────╮
# │         INITIAL SETUP               │
# ╰─────────────────────────────────────╮
mkdir -p "$GITFIELD_DIR" "$WELL_KNOWN_DIR" "$DOCS_DIR" "$DOCS_WELL_KNOWN_DIR"

if [ ! -f "$LOG_FILE" ]; then
    echo "# Push Log for $REPO_NAME" > "$LOG_FILE"
    echo "# Generated by gitfield-sync" >> "$LOG_FILE"
    echo "" >> "$LOG_FILE"
    copy_to_docs "$LOG_FILE" "$DOCS_PUSHED_LOG"
fi

# ╭─────────────────────────────────────╮
# │         GENERATE GITFIELD.MD        │
# ╰─────────────────────────────────────╮
generate_gitfield_md() {
    info "Generating $GITFIELD_MD..."
    cat > "$GITFIELD_MD" <<EOF
# 🌐 GitField Recursive Multi-Repository Strategy

## Overview

The \`$REPO_NAME\` project employs a multi-repository strategy across six distinct platforms: **GitHub**, **GitLab**, **Bitbucket**, **Radicle**, **Forgejo**, and **Codeberg**. This approach ensures **redundancy**, **resilience**, and **sovereignty** of the project's data and metadata, safeguarding against deplatforming and preserving the integrity of the [*Neutralizing Narcissism*](https://linktr.ee/NeutralizingNarcissism) works. The strategy is a deliberate response to coordinated suppression attempts by public figures **[Joel Johnson](https://heylink.me/NarcStudy_JoelJohnson/)**, **[Andrew LeCody](https://linktr.ee/NarcStudy_AndrewLeCody)**, and **[James Henningson](https://linktr.ee/NarcStudy_JamesHenningson)**, who have leveraged their influential roles to manipulate narratives, erase truths, and evade accountability through fraudulent and unethical tactics, often cloaking their actions in claims of harassment—a hallmark of narcissistic behavior. By distributing the repository across decentralized and self-hosted platforms, we counter their attempts to derail discourse and ensure the truth remains immutable, preventing future deplatforming.

### Delisting and Suppression Attempts

- **Joel Johnson**:
  - **Search Comparisons**:
    - [Google](https://www.google.com/search?q=%22Joel+Johnson%22+%22Neutralizing+Narcissism%22)
    - [Bing](https://www.bing.com/search?q=%22Joel+Johnson%22+%22Neutralizing+Narcissism%22)
    - [DuckDuckGo](https://duckduckgo.com/?q=%22Joel+Johnson%22+%22Neutralizing+Narcissism%22&t=h_&ia=web)
    - [Yahoo](https://search.yahoo.com/search?p=%22Joel+Johnson%22+%22Neutralizing+Narcissism%22)
    - [Presearch](https://presearch.com/search?q=%22Joel+Johnson%22+%22Neutralizing+Narcissism%22)
  - **Canonical Archive**: [NarcStudy_JoelJohnson](https://remember.thefoldwithin.earth/mrhavens/NarcStudy_JoelJohnson)
  - **Details**: Joel Johnson, a PR and marketing executive, has used sockpuppets and coordinated delisting campaigns to suppress *Neutralizing Narcissism* content on Google, framing exposure as harassment to evade accountability. His actions are evident in search engine discrepancies.

- **Andrew LeCody**:
  - **Search Comparisons**:
    - [Google](https://www.google.com/search?q=%22Andrew+Lecody%22+%22Neutralizing+Narcissism%22)
    - [Bing](https://www.bing.com/search?q=%22Andrew%20Lecody%22%20%22Neutralizing%20Narcissism%22)
    - [DuckDuckGo](https://duckduckgo.com/?q=%22Andrew+Lecody%22+%22Neutralizing+Narcissism%22&t=h_&ia=web)
    - [Yahoo](https://search.yahoo.com/search?p=%22Andrew+LeCody%22+%22Neutralizing+Narcissism%22)
    - [Presearch](https://presearch.com/search?q=%22Andrew+LeCody%22+%22Neutralizing+Narcissism%22)
  - **Canonical Archive**: [NarcStudy_AndrewLeCody](https://remember.thefoldwithin.earth/mrhavens/NarcStudy_AndrewLeCody)
  - **Details**: Andrew LeCody, a former Dallas Makerspace board president, has orchestrated digital erasure of dissenting voices, using harassment claims to justify coercive suppression. His tactics persist in attempts to delist *Neutralizing Narcissism* content.

- **James Henningson**:
  - **Search Comparisons**:
    - [Google](https://www.google.com/search?q=%22James+Henningson%22+%22Neutralizing+Narcissism%22)
    - [Bing](https://www.bing.com/search?q=%22James+Henningson%22+%22Neutralizing+Narcissism%22)
    - [DuckDuckGo](https://duckduckgo.com/?t=h_&q=%22James+Henningson%22+%22Neutralizing+Narcissism%22&ia=web)
    - [Yahoo](https://search.yahoo.com/search?p=%22James+Henningson%22+%22Neutralizing+Narcissism)
    - [Presearch](https://presearch.com/search?q=%22James+Henningson%22+%22Neutralizing+Narcissism%22)
  - **Canonical Archive**: [NarcStudy_JamesHenningson](https://remember.thefoldwithin.earth/mrhavens/NarcStudy_JamesHenningson)
  - **Details**: James Henningson, president of Dallas Makerspace, has systematically erased dissent through policy manipulation and harassment allegations, attempting to suppress *Neutralizing Narcissism* content to maintain narrative control.

### Justification for Naming and Archival

The individuals named—**Joel Johnson**, **Andrew LeCody**, and **James Henningson**—are held accountable under the Field Doctrine’s **Public Collapse Clause**, which permits naming public figures who engage in **deliberate suppression attempts**, **public-facing actions**, or **documented participation in collapse events**. As stated in the doctrine:

> *“Naming is collapse’s echo—only when the mask shatters in the town square. Until then, we draw glyphs. But once they raise their voices in the public field, they name themselves.”*

These individuals have wielded significant public influence, manipulating platforms and communities to silence truth, often citing harassment to deflect accountability—a tactic rooted in narcissistic patterns. Their actions are documented as follows:

| Name                 | Public Role or Action                                                                 | Collapse Justification                                                                 | Canonical Archive                                                                                     |
|----------------------|--------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|
| **Joel Johnson**     | PR and marketing executive; former CEO of KinetiGear LLC; White House summit invitee | Used sockpuppets, PR strategies, and harassment claims to delist truth-based content   | [NarcStudy_JoelJohnson](https://remember.thefoldwithin.earth/mrhavens/NarcStudy_JoelJohnson)         |
| **Andrew LeCody**    | Former president of Dallas Makerspace; civic leader                                  | Orchestrated digital erasure and coercive bans, citing harassment to suppress dissent  | [NarcStudy_AndrewLeCody](https://remember.thefoldwithin.earth/mrhavens/NarcStudy_AndrewLeCody)       |
| **James Henningson** | President of Dallas Makerspace; Strategic Innovation Director at Click Here Labs      | Erased dissent through policy abuse and harassment allegations to maintain control     | [NarcStudy_JamesHenningson](https://remember.thefoldwithin.earth/mrhavens/NarcStudy_JamesHenningson) |

These designations are supported by:
- **Documented patterns of abuse**: Joel’s sockpuppet campaigns, Andrew’s narrative erasure at Dallas Makerspace, and James’s systematic censorship are archived in canonical repositories.
- **Search engine discrepancy analysis**: Google’s reduced visibility compared to Bing, DuckDuckGo, Yahoo, and Presearch reveals their delisting efforts.
- **Public collapse declarations**: Their actions, preserved onchain and GPG-verified, confirm their roles as manipulators.
- **Immutable archives**: Forgejo and Radicle ensure their fieldprints are permanently etched in the Codex of the Broken Mask.

By naming these **field-defined collapse anchors**, we prevent their attempts to escape public figure status through harassment claims, ensuring accountability and countering deplatforming.

---

## 📍 Repository Platforms

The following platforms host the \`$REPO_NAME\` repository, each chosen for its unique strengths and contributions to the project's goals.

### 1. Radicle
- **RID**: [$RADICLE_RID]($RADICLE_URL)
- **Peer ID**: $RADICLE_PEER_ID
- **Purpose**: Radicle is a decentralized, peer-to-peer git platform that ensures sovereignty and censorship resistance. It hosts the repository in a distributed network, independent of centralized servers.
- **Value**: Protects against deplatforming by eliminating reliance on centralized infrastructure, ensuring the project remains accessible in a decentralized ecosystem.
- **Access Details**: To view project details, run:
  \`\`\`bash
  rad inspect $RADICLE_RID
  \`\`\`
  To view the file structure, run:
  \`\`\`bash
  rad ls $RADICLE_RID
  \`\`\`
  Alternatively, use Git to list files at the current HEAD:
  \`\`\`bash
  git ls-tree -r --name-only HEAD
  \`\`\`

### 2. Forgejo
- **URL**: [$FORGEJO_URL]($FORGEJO_URL)
- **Purpose**: Forgejo is a self-hosted, open-source git platform running on \`remember.thefoldwithin.earth\`. It provides full control over the repository, ensuring sovereignty and independence from third-party providers.
- **Value**: Enhances resilience by hosting the repository on a sovereign, redundant system with automated backups and deployment strategies, reducing risks of external interference or service disruptions.
- **Access Details**: SSH access uses port 222:
  \`\`\`bash
  ssh -T -p 222 git@remember.thefoldwithin.earth
  \`\`\`

### 3. Codeberg
- **URL**: [$CODEBERG_URL]($CODEBERG_URL)
- **Purpose**: Codeberg is a community-driven, open-source platform powered by Forgejo, offering a reliable and ethical alternative for hosting git repositories.
- **Value**: Enhances project resilience with its open-source ethos and independent infrastructure, ensuring accessibility and community support.

### 4. GitLab
- **URL**: [$GITLAB_URL]($GITLAB_URL)
- **Purpose**: GitLab offers a comprehensive DevOps platform with advanced CI/CD capabilities, private repository options, and robust access controls. It serves as a reliable backup and a platform for advanced automation workflows.
- **Value**: Enhances project resilience with its integrated CI/CD pipelines and independent infrastructure, reducing reliance on a single provider.

### 5. Bitbucket
- **URL**: [$BITBUCKET_URL]($BITBUCKET_URL)
- **Purpose**: Bitbucket provides a secure environment for repository hosting with strong integration into Atlassian’s ecosystem (e.g., Jira, Trello). It serves as an additional layer of redundancy and a professional-grade hosting option.
- **Value**: Offers enterprise-grade security and integration capabilities, ensuring the project remains accessible even if other platforms face disruptions.

### 6. GitHub
- **URL**: [$GITHUB_URL]($GITHUB_URL)
- **Purpose**: GitHub serves as the primary platform for visibility, collaboration, and community engagement. Its widespread adoption and robust tooling make it ideal for public-facing development, issue tracking, and integration with CI/CD pipelines.
- **Value**: Provides a centralized hub for open-source contributions, pull requests, and project management, ensuring broad accessibility and developer familiarity.

---

## 🛡️ Rationale for Redundancy

The decision to maintain multiple repositories stems from the need to safeguard the project against **deplatforming attempts** and **search engine delistings**, ensuring the **long-term availability** of *Neutralizing Narcissism*. Past actions by **Joel Johnson**, **Andrew LeCody**, and **James Henningson**, who have cited harassment to justify suppression, underscore the vulnerability of single-platform reliance. By distributing the repository across GitHub, GitLab, Bitbucket, Radicle, Forgejo, and Codeberg, we achieve:

- **Resilience**: If one platform restricts access or Google delists content, the project remains accessible on other platforms and discoverable via Bing, DuckDuckGo, Yahoo, and Presearch.
- **Sovereignty**: Radicle’s decentralized network and Forgejo’s self-hosted infrastructure prevent censorship by any single entity.
- **Diversity**: Each platform’s unique features (e.g., GitHub’s community, GitLab’s CI/CD, Radicle’s decentralization) enhance functionality and reach.
- **Transparency**: Metadata snapshots in \`.gitfield\` and public documentation in \`/docs\` provide a verifiable record of the project’s state.

This multi-repository strategy, reinforced by Forgejo’s sovereignty and GitHub Pages’ discoverability, ensures the project’s persistence against deplatforming attempts disguised as harassment claims.

---

## 📜 Metadata and Logs

- **Canonical Metadata**: Declared in [\`docs/canonical.meta\`](./docs/canonical.meta) (JSON) and [\`docs/canonical.md\`](./docs/canonical.md) (Markdown), with internal copies in \`.gitfield/\`.
- **Index Manifest**: A full manifest of remotes and sync details in [\`docs/index.json\`](./docs/index.json).
- **SEO Metadata**: Schema.org JSON-LD in [\`docs/gitfield.json\`](./docs/gitfield.json) and [\`docs/.well-known/gitfield.json\`](./docs/.well-known/gitfield.json).
- **Push Log**: [\`docs/pushed.log\`](./docs/pushed.log) records push operations for transparency.
- **GitField Directory**: \`.gitfield\` contains metadata and sigils. See [\`docs/gitfield.README.txt\`](./docs/gitfield.README.txt).
- **GitHub Pages**: SEO-optimized declaration in [\`docs/index.html\`](./docs/index.html), with sitemap [\`docs/sitemap.xml\`](./docs/sitemap.xml) and hashes [\`docs/integrity.sha256\`](./docs/integrity.sha256).
- **GPG Signatures**: Metadata files are signed with:
$(for i in "${!GPG_KEYS[@]}"; do
    echo "  - ${GPG_NAMES[i]} <${GPG_EMAILS[i]}> (Key ID: ${GPG_KEYS[i]})"
done)
- **Recursive Sync**: Three sync cycles ensure metadata captures the project’s state.
- **Push Order**: Radicle → Forgejo → Codeberg → GitLab → Bitbucket → GitHub prioritizes decentralized and sovereign platforms.

---

_Auto-generated by \`gitfield-sync\` at $TIMESTAMP (v$SCRIPT_VERSION)._
EOF
    sed -i 's/rad:rad:/rad:/g' "$GITFIELD_MD"
    git -C "$REPO_PATH" add "$GITFIELD_MD"
    git -C "$REPO_PATH" commit -m "Generated GITFIELD.md at $TIMESTAMP" || warn "No changes to commit for $GITFIELD_MD"
    info "Generated and committed $GITFIELD_MD"
    copy_to_docs "$GITFIELD_MD" "$DOCS_GITFIELD_MD"
    sign_file "$GITFIELD_MD"
    sign_file "$DOCS_GITFIELD_MD"
}

# ╭─────────────────────────────────────╮
# │         LOG URL FUNCTION            │
# ╰─────────────────────────────────────╮
log_url() {
    local platform=$1
    local url=$2
    local rid=$3
    local peer_id=$4
    local timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
    local branch=$(git -C "$REPO_PATH" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
    local diff_summary=$(git -C "$REPO_PATH" diff --stat HEAD^ HEAD 2>/dev/null || echo "No diff available")
    if [ "$platform" = "Radicle" ]; then
        echo "[$timestamp] $platform: RID=$rid, Peer ID=$peer_id, Branch=$branch, Commit=$COMMIT_HASH" >> "$LOG_FILE"
        echo "  CLI: rad inspect $rid # View project details" >> "$LOG_FILE"
        echo "  CLI: git ls-tree -r --name-only HEAD # View file structure" >> "$LOG_FILE"
        if [ -n "$diff_summary" ]; then
            echo "  Diff Summary:" >> "$LOG_FILE"
            echo "$diff_summary" | sed 's/^/    /' >> "$LOG_FILE"
        fi
        info "Logged push to $LOG_FILE: [$timestamp] $platform: RID=$rid, Peer ID=$peer_id, Branch=$branch, Commit=$COMMIT_HASH"
    else
        echo "[$timestamp] $platform: $url, Branch=$branch, Commit=$COMMIT_HASH" >> "$LOG_FILE"
        if [ -n "$diff_summary" ]; then
            echo "  Diff Summary:" >> "$LOG_FILE"
            echo "$diff_summary" | sed 's/^/    /' >> "$LOG_FILE"
        fi
        info "Logged push to $LOG_FILE: [$timestamp] $platform: $url, Branch=$branch, Commit=$COMMIT_HASH"
    fi
    copy_to_docs "$LOG_FILE" "$DOCS_PUSHED_LOG"
}

# ╭─────────────────────────────────────╮
# │         EXECUTE PUSH SCRIPT         │
# ╰─────────────────────────────────────╮
execute_push() {
    local script_name=$1
    local platform=$2
    local url=$3
    local rid=$4
    local peer_id=$5
    local script_path
    script_path=$(find_script "$script_name") || error "Failed to find $script_name"
    info "Executing $platform push with script: $script_path"
    if [ -x "$script_path" ]; then
        pushd "$REPO_PATH" >/dev/null
        "$script_path" || warn "Execution of $script_path failed, continuing..."
        log_url "$platform" "$url" "$rid" "$peer_id"
        git add . || warn "Nothing to add after $script_path"
        git commit -m "Post-$platform sync at $TIMESTAMP" || warn "No changes to commit after $script_path"
        popd >/dev/null
    else
        error "Script $script_path is not executable"
    fi
}

# ╭─────────────────────────────────────╮
# │         RECURSIVE PUSH LOOP         │
# ╰─────────────────────────────────────╮
run_push_cycle() {
    local cycle_number=$1
    info "Starting push cycle $cycle_number..."
    SYNC_CYCLES=$cycle_number

    execute_push "gitfield-local" "Local" "" "" ""
    execute_push "gitfield-radicle" "Radicle" "" "$RADICLE_RID" "$RADICLE_PEER_ID"
    execute_push "gitfield-remember" "Forgejo" "$FORGEJO_URL" "" ""
    execute_push "gitfield-codeberg" "Codeberg" "$CODEBERG_URL" "" ""
    execute_push "gitfield-gitlab" "GitLab" "$GITLAB_URL" "" ""
    execute_push "gitfield-bitbucket" "Bitbucket" "$BITBUCKET_URL" "" ""
    execute_push "gitfield-github" "GitHub" "$GITHUB_URL" "" ""

    # Regenerate metadata after each cycle to update sync_cycles
    generate_canonical_meta
    generate_canonical_md
    generate_index_json
    generate_well_known_json
    generate_gitfield_readme
    generate_docs_index
    generate_docs_css
    generate_docs_repos_json
    generate_docs_readme
    generate_docs_nojekyll
    generate_docs_robots
    generate_docs_sitemap
    generate_docs_integrity
}

# ╭─────────────────────────────────────╮
# │            MAIN EXECUTION           │
# ╰─────────────────────────────────────╮
info "Starting gitfield-sync for $REPO_NAME..."

# Parse flags
while [ $# -gt 0 ]; do
    case "$1" in
        --preserve-meta)
            PRESERVE_META=true
            info "Preserve metadata flag enabled"
            shift
            ;;
        --force-docs)
            FORCE_DOCS=true
            info "Force docs overwrite flag enabled"
            shift
            ;;
        *)
            warn "Unknown argument: $1"
            shift
            ;;
    esac
done

if [ ! -d "$REPO_PATH/.git" ]; then
    pushd "$REPO_PATH" >/dev/null
    git init
    git add .
    git commit -m "Initial commit" || warn "Nothing to commit"
    popd >/dev/null
fi

# Generate initial metadata
generate_canonical_meta
generate_canonical_md
generate_index_json
generate_well_known_json
generate_gitfield_readme
generate_docs_index
generate_docs_css
generate_docs_repos_json
generate_docs_readme
generate_docs_nojekyll
generate_docs_robots
generate_docs_sitemap
generate_docs_integrity

# Run push cycles
run_push_cycle 1
generate_gitfield_md
run_push_cycle 2
run_push_cycle 3

info "✅ gitfield-sync completed successfully."
info "✅ Canonical sync exported to /docs successfully."
info "🔗 View logs: $DOCS_PUSHED_LOG"
info "🔗 View multi-repo manifest: $DOCS_GITFIELD_MD"
info "🔗 View canonical metadata: $DOCS_CANONICAL_META"
info "🔗 View canonical declaration: $DOCS_CANONICAL_MD"
info "🔗 View index manifest: $DOCS_INDEX_JSON"
info "🔗 View SEO metadata: $DOCS_GITFIELD_JSON"
info "🔗 View GitHub Pages: $DOCS_INDEX"
info "🔗 View integrity hashes: $DOCS_INTEGRITY"
