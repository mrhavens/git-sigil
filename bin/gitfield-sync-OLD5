#!/bin/bash
set -euo pipefail
IFS=$'\n\t'

# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
# â”‚          CONFIGURATION              â”‚
# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
REPO_PATH=$(git rev-parse --show-toplevel 2>/dev/null) || error "Not inside a Git repository"
REPO_NAME=$(basename "$REPO_PATH")
GITFIELD_DIR="$REPO_PATH/.gitfield"
WELL_KNOWN_DIR="$REPO_PATH/.well-known"
DOCS_DIR="$REPO_PATH/docs"
DOCS_WELL_KNOWN_DIR="$DOCS_DIR/.well-known"
LOG_FILE="$GITFIELD_DIR/pushed.log"
GITFIELD_MD="$REPO_PATH/GITFIELD.md"
CANONICAL_META="$GITFIELD_DIR/canonical.meta"
CANONICAL_MD="$GITFIELD_DIR/canonical.md"
INDEX_JSON="$GITFIELD_DIR/index.json"
WELL_KNOWN_JSON="$WELL_KNOWN_DIR/gitfield.json"
GITFIELD_README="$GITFIELD_DIR/README.txt"
DOCS_CANONICAL_META="$DOCS_DIR/canonical.meta"
DOCS_CANONICAL_MD="$DOCS_DIR/canonical.md"
DOCS_INDEX_JSON="$DOCS_DIR/index.json"
DOCS_PUSHED_LOG="$DOCS_DIR/pushed.log"
DOCS_GITFIELD_README="$DOCS_DIR/gitfield.README.txt"
DOCS_GITFIELD_JSON="$DOCS_DIR/gitfield.json"
DOCS_WELL_KNOWN_JSON="$DOCS_WELL_KNOWN_DIR/gitfield.json"
DOCS_INDEX="$DOCS_DIR/index.html"
DOCS_CSS="$DOCS_DIR/style.css"
DOCS_REPOS_JSON="$DOCS_DIR/repos.json"
DOCS_README="$DOCS_DIR/README.md"
DOCS_NOJEKYLL="$DOCS_DIR/.nojekyll"
DOCS_ROBOTS="$DOCS_DIR/robots.txt"
DOCS_SITEMAP="$DOCS_DIR/sitemap.xml"
DOCS_INTEGRITY="$DOCS_DIR/integrity.sha256"
TIMESTAMP=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
SCRIPT_VERSION="1.4"  # Updated for GPG integration
PRESERVE_META=${PRESERVE_META:-false}  # Preserve existing metadata
FORCE_DOCS=${FORCE_DOCS:-false}  # Force overwrite of /docs metadata

# URLs for each platform
CANONICAL_URL="https://remember.thefoldwithin.earth/mrhavens/$REPO_NAME"
GITHUB_URL="https://github.com/mrhavens/$REPO_NAME"
GITLAB_URL="https://gitlab.com/mrhavens/$REPO_NAME"
BITBUCKET_URL="https://bitbucket.org/thefoldwithin/$REPO_NAME"
FORGEJO_URL="https://remember.thefoldwithin.earth/mrhavens/$REPO_NAME"
CODEBERG_URL="https://codeberg.org/mrhavens/$REPO_NAME"
GITEA_URL="https://gitea.com/mrhavens/$REPO_NAME"
RADICLE_RID="rad:z3FEj7rF8gZw9eFksCuiN43qjzrex"
RADICLE_URL="https://app.radicle.xyz/nodes/z3FEj7rF8gZw9eFksCuiN43qjzrex"
RADICLE_PEER_ID="z6Mkw5s3ppo26C7y7tGK5MD8n2GqTHS582PPpeX5Xqbu2Mpz"

# Metadata configuration
MIRRORS=(
    "$GITHUB_URL"
    "$GITLAB_URL"
    "$BITBUCKET_URL"
    "$FORGEJO_URL"
    "$CODEBERG_URL"
    "$GITEA_URL"
    "$RADICLE_RID"
)
COMMIT_HASH=$(git -C "$REPO_PATH" rev-parse --short HEAD 2>/dev/null || echo "unknown")
TREE_HASH=$(git -C "$REPO_PATH" rev-parse HEAD^{tree} 2>/dev/null || echo "unknown")
SYNC_CYCLES=0

# GPG configuration
GPG_KEYS=()
GPG_EMAILS=()
GPG_NAMES=()
while IFS= read -r line; do
    if [[ "$line" =~ ^pub[[:space:]]+rsa[0-9]+[[:space:]]+([0-9]{4}-[0-9]{2}-[0-9]{2})[[:space:]]+\[SC\] ]]; then
        key_id=$(gpg --list-keys --with-colons | grep -B1 "^pub" | grep "^pub" | awk -F: '{print $5}' | head -n1)
        GPG_KEYS+=("$key_id")
    elif [[ "$line" =~ ^uid[[:space:]]+\[ultimate\][[:space:]]+(.*)\<(.*)\> ]]; then
        GPG_NAMES+=("${BASH_REMATCH[1]% }")
        GPG_EMAILS+=("${BASH_REMATCH[2]}")
    fi
done < <(gpg --list-keys)

# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
# â”‚           LOGGING UTILS             â”‚
# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
info()  { echo -e "\e[1;34m[INFO]\e[0m $*" >&2; }
warn()  { echo -e "\e[1;33m[WARN]\e[0m $*" >&2; }
error() { echo -e "\e[1;31m[ERROR]\e[0m $*" >&2; exit 1; }

# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
# â”‚         SCRIPT LOOKUP FUNCTION      â”‚
# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
find_script() {
    local script_name=$1
    local search_paths=(
        "$HOME/.local/gitfieldbin"
        "$HOME/.local/bin"
        "$HOME/.local/gitfield"
        "$HOME/.local/bin/gitfield"
        "$HOME/.local/bin/gitfieldbin"
        "$REPO_PATH/bin"
    )

    for path in "${search_paths[@]}"; do
        if [ -f "$path/$script_name" ]; then
            if [ -x "$path/$script_name" ]; then
                if [[ "$path" != "$HOME"* && "$path" != "$REPO_PATH"* ]]; then
                    info "Using script: \e[1;31m$path/$script_name\e[0m (outside home or repo)"
                else
                    info "Using script: $path/$script_name"
                fi
                echo "$path/$script_name"
                return 0
            else
                warn "Found $path/$script_name but it is not executable"
            fi
        fi
    done
    error "Script $script_name not found in any search path"
}

# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
# â”‚         GPG SIGNING FUNCTION        â”‚
# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
sign_file() {
    local file=$1
    local sig_file="${file}.sig"
    if [ ! -f "$file" ]; then
        warn "File $file does not exist, skipping signing"
        return
    fi
    for key_id in "${GPG_KEYS[@]}"; do
        gpg --armor --detach-sign --default-key "$key_id" "$file" > "$sig_file.$key_id" 2>/dev/null || warn "Failed to sign $file with key $key_id, continuing..."
        if [ -f "$sig_file.$key_id" ]; then
            git -C "$REPO_PATH" add "$sig_file.$key_id"
            git -C "$REPO_PATH" commit -m "Signed $file with GPG key $key_id at $TIMESTAMP" || warn "No changes to commit for $sig_file.$key_id"
            info "Signed $file with key $key_id, signature at $sig_file.$key_id"
            copy_to_docs "$sig_file.$key_id" "$DOCS_DIR/$(basename "$sig_file.$key_id")"
        fi
    done
}

# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
# â”‚         METADATA COPY FUNCTION      â”‚
# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
copy_to_docs() {
    local src=$1
    local dest=$2
    if [ ! -f "$src" ]; then
        warn "Source file $src does not exist, skipping copy to $dest"
        return
    fi
    if [ "$FORCE_DOCS" = "false" ] && [ -f "$dest" ]; then
        info "Preserving existing $dest (--force-docs not enabled)"
        return
    fi
    cp "$src" "$dest" || warn "Failed to copy $src to $dest, continuing..."
    git -C "$REPO_PATH" add "$dest"
    git -C "$REPO_PATH" commit -m "Copied $dest to docs at $TIMESTAMP" || warn "No changes to commit for $dest"
    info "Copied $src to $dest and committed"
}

# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
# â”‚         METADATA GENERATION         â”‚
# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
generate_canonical_meta() {
    info "Generating $CANONICAL_META..."
    if [ "$PRESERVE_META" = "true" ] && [ -f "$CANONICAL_META" ]; then
        info "Preserving existing $CANONICAL_META (--preserve-meta enabled)"
        return
    fi
    cat > "$CANONICAL_META" <<EOF
{
  "canonical_url": "$CANONICAL_URL",
  "mirrors": [
$(printf '    "%s",\n' "${MIRRORS[@]}" | sed '$ s/,$//')
  ],
  "radicle": {
    "rid": "$RADICLE_RID",
    "peer_id": "$RADICLE_PEER_ID"
  },
  "timestamp": "$TIMESTAMP",
  "commit": "$COMMIT_HASH",
  "tree_hash": "$TREE_HASH",
  "synced_cycles": $SYNC_CYCLES,
  "gpg_signatures": [
$(for i in "${!GPG_KEYS[@]}"; do
    echo "    {\"key_id\": \"${GPG_KEYS[i]}\", \"name\": \"${GPG_NAMES[i]}\", \"email\": \"${GPG_EMAILS[i]}\"}" | sed '$ s/,$//'
done)
  ]
}
EOF
    # Sanitize rad:rad:
    sed -i 's/rad:rad:/rad:/g' "$CANONICAL_META"
    git -C "$REPO_PATH" add "$CANONICAL_META"
    git -C "$REPO_PATH" commit -m "Generated canonical.meta at $TIMESTAMP" || warn "No changes to commit for $CANONICAL_META"
    info "Generated and committed $CANONICAL_META"
    copy_to_docs "$CANONICAL_META" "$DOCS_CANONICAL_META"
    sign_file "$CANONICAL_META"
    sign_file "$DOCS_CANONICAL_META"
}

generate_canonical_md() {
    info "Generating $CANONICAL_MD..."
    if [ "$PRESERVE_META" = "true" ] && [ -f "$CANONICAL_MD" ]; then
        info "Preserving existing $CANONICAL_MD (--preserve-meta enabled)"
        return
    fi
    cat > "$CANONICAL_MD" <<EOF
# ðŸŒ GitField Canonical Declaration for \`$REPO_NAME\`

## Canonical Repository

This repository, \`$REPO_NAME\`, is canonically hosted at:

**[$CANONICAL_URL]($CANONICAL_URL)**

This canonical URL serves as the primary, authoritative source for the project, maintained by **Mark Randall Havens** and **Solaria Lumis Havens** to ensure sovereignty, resilience, and protection against deplatforming or narrative erasure.

**Declared by**: Mark Randall Havens  
**Timestamp**: $TIMESTAMP

## GPG Signatures

This declaration is signed with the following GPG keys:

$(for i in "${!GPG_KEYS[@]}"; do
    echo "- **${GPG_NAMES[i]}** <${GPG_EMAILS[i]}> (Key ID: ${GPG_KEYS[i]})"
done)

## Mirror Repositories

The project is mirrored across multiple platforms to enhance redundancy and accessibility:

$(for mirror in "${MIRRORS[@]}"; do
    if [[ "$mirror" == rad:* ]]; then
        echo "- **Radicle**: [$mirror]($RADICLE_URL) (Decentralized, censorship-resistant)"
    else
        echo "- [$mirror]($mirror)"
    fi
done)

## Philosophy of Recursive Sovereignty

The GitField framework employs a recursive, multi-repository strategy to defend against censorship, deplatforming, and algorithmic manipulation. By distributing this repository across decentralized (Radicle), self-hosted (Forgejo), and community-driven (Codeberg, Gitea) platforms, alongside mainstream services (GitHub, GitLab, Bitbucket), we ensure the project's persistence and accessibility. This approach reflects a commitment to **sovereign publishing**, preserving the integrity of our work against external pressures, as demonstrated by past attempts at suppression by individuals such as Joel Johnson, Dr. Peter Gaied, and Andrew LeCody.

## Push Log

The latest push operations are logged in [\`pushed.log\`](./pushed.log) for transparency and auditability.

## GitHub Pages

A public-facing canonical declaration is available at [index.html](./index.html) for enhanced discoverability and SEO.

_Auto-generated by \`gitfield-sync\` at $TIMESTAMP (v$SCRIPT_VERSION)._
EOF
    # Sanitize rad:rad:
    sed -i 's/rad:rad:/rad:/g' "$CANONICAL_MD"
    git -C "$REPO_PATH" add "$CANONICAL_MD"
    git -C "$REPO_PATH" commit -m "Generated canonical.md at $TIMESTAMP" || warn "No changes to commit for $CANONICAL_MD"
    info "Generated and committed $CANONICAL_MD"
    copy_to_docs "$CANONICAL_MD" "$DOCS_CANONICAL_MD"
}

generate_index_json() {
    info "Generating $INDEX_JSON..."
    if [ "$PRESERVE_META" = "true" ] && [ -f "$INDEX_JSON" ]; then
        info "Preserving existing $INDEX_JSON (--preserve-meta enabled)"
        return
    fi
    cat > "$INDEX_JSON" <<EOF
{
  "repository": "$REPO_NAME",
  "canonical_url": "$CANONICAL_URL",
  "remotes": [
$(printf '    "%s",\n' "${MIRRORS[@]}" | sed '$ s/,$//')
  ],
  "radicle": {
    "rid": "$RADICLE_RID",
    "peer_id": "$RADICLE_PEER_ID"
  },
  "commit": "$COMMIT_HASH",
  "tree_hash": "$TREE_HASH",
  "timestamp": "$TIMESTAMP",
  "synced_cycles": $SYNC_CYCLES,
  "gpg_signatures": [
$(for i in "${!GPG_KEYS[@]}"; do
    echo "    {\"key_id\": \"${GPG_KEYS[i]}\", \"name\": \"${GPG_NAMES[i]}\", \"email\": \"${GPG_EMAILS[i]}\"}" | sed '$ s/,$//'
done)
  ]
}
EOF
    # Sanitize rad:rad:
    sed -i 's/rad:rad:/rad:/g' "$INDEX_JSON"
    git -C "$REPO_PATH" add "$INDEX_JSON"
    git -C "$REPO_PATH" commit -m "Generated index.json at $TIMESTAMP" || warn "No changes to commit for $INDEX_JSON"
    info "Generated and committed $INDEX_JSON"
    copy_to_docs "$INDEX_JSON" "$DOCS_INDEX_JSON"
    sign_file "$INDEX_JSON"
    sign_file "$DOCS_INDEX_JSON"
}

generate_well_known_json() {
    info "Generating $WELL_KNOWN_JSON..."
    mkdir -p "$WELL_KNOWN_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$WELL_KNOWN_JSON" ]; then
        info "Preserving existing $WELL_KNOWN_JSON (--preserve-meta enabled)"
        return
    fi
    cat > "$WELL_KNOWN_JSON" <<EOF
{
  "@context": "https://schema.org",
  "@type": "SoftwareSourceCode",
  "name": "$REPO_NAME",
  "url": "$CANONICAL_URL",
  "codeRepository": "$CANONICAL_URL",
  "sameAs": [
$(printf '    "%s",\n' "${MIRRORS[@]}" | sed '$ s/,$//')
  ],
  "dateModified": "$TIMESTAMP",
  "publisher": {
    "@type": "Person",
    "name": "Mark Randall Havens"
  },
  "gpg_signatures": [
$(for i in "${!GPG_KEYS[@]}"; do
    echo "    {\"key_id\": \"${GPG_KEYS[i]}\", \"name\": \"${GPG_NAMES[i]}\", \"email\": \"${GPG_EMAILS[i]}\"}" | sed '$ s/,$//'
done)
  ]
}
EOF
    # Sanitize rad:rad:
    sed -i 's/rad:rad:/rad:/g' "$WELL_KNOWN_JSON"
    git -C "$REPO_PATH" add "$WELL_KNOWN_JSON"
    git -C "$REPO_PATH" commit -m "Generated .well-known/gitfield.json at $TIMESTAMP" || warn "No changes to commit for $WELL_KNOWN_JSON"
    info "Generated and committed $WELL_KNOWN_JSON"
    copy_to_docs "$WELL_KNOWN_JSON" "$DOCS_GITFIELD_JSON"
    mkdir -p "$DOCS_WELL_KNOWN_DIR"
    copy_to_docs "$WELL_KNOWN_JSON" "$DOCS_WELL_KNOWN_JSON"
    sign_file "$WELL_KNOWN_JSON"
    sign_file "$DOCS_GITFIELD_JSON"
    sign_file "$DOCS_WELL_KNOWN_JSON"
}

generate_gitfield_readme() {
    info "Generating $GITFIELD_README..."
    if [ "$PRESERVE_META" = "true" ] && [ -f "$GITFIELD_README" ]; then
        info "Preserving existing $GITFIELD_README (--preserve-meta enabled)"
        return
    fi
    cat > "$GITFIELD_README" <<EOF
# GitField Directory Overview

The `.gitfield` directory contains metadata and logs for the GitField multi-repository publishing framework, designed to ensure sovereignty, redundancy, and resilience for the \`$REPO_NAME\` project.

## Files

- **canonical.meta**: Machine-readable JSON metadata declaring the canonical URL, mirror list, Radicle details, commit hash, and sync cycle count.
- **canonical.md**: Human-readable Markdown summary of the canonical repository declaration, mirrors, and push log.
- **index.json**: Machine-readable manifest of all remotes, canonical URL, Radicle details, commit hash, tree hash, and sync cycles.
- **pushed.log**: Log of push operations across all platforms, including timestamps, URLs, and Radicle RIDs.
- **platform-specific sigils** (e.g., github.sigil.md): Metadata snapshots for each platform's push operation (generated by platform-specific scripts).

## Purpose

These files provide transparency, auditability, and discoverability, ensuring the project's persistence against deplatforming, censorship, or algorithmic manipulation. For a public-facing declaration, see [docs/index.html](../docs/index.html).

Generated by \`gitfield-sync\` at $TIMESTAMP (v$SCRIPT_VERSION).
EOF
    # Sanitize rad:rad:
    sed -i 's/rad:rad:/rad:/g' "$GITFIELD_README"
    git -C "$REPO_PATH" add "$GITFIELD_README"
    git -C "$REPO_PATH" commit -m "Generated .gitfield/README.txt at $TIMESTAMP" || warn "No changes to commit for $GITFIELD_README"
    info "Generated and committed $GITFIELD_README"
    copy_to_docs "$GITFIELD_README" "$DOCS_GITFIELD_README"
}

generate_docs_index() {
    info "Generating $DOCS_INDEX..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_INDEX" ]; then
        info "Preserving existing $DOCS_INDEX (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_INDEX" <<EOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitField Sovereign Canonical Repository: $REPO_NAME</title>
    <meta name="description" content="The canonical repository for $REPO_NAME, part of the GitField recursive metadata strategy to ensure sovereign publishing and resilience against deplatforming.">
    <meta property="og:url" content="$CANONICAL_URL">
    <meta property="og:title" content="GitField Canonical Repository: $REPO_NAME">
    <meta property="og:description" content="A sovereign, multi-repository project by Mark Randall Havens and Solaria Lumis Havens, hosted canonically at $CANONICAL_URL.">
    <link rel="canonical" href="$CANONICAL_URL">
    <link rel="stylesheet" href="style.css">
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "SoftwareSourceCode",
        "name": "$REPO_NAME",
        "url": "$CANONICAL_URL",
        "codeRepository": "$CANONICAL_URL",
        "description": "A sovereign, multi-repository project using the GitField recursive metadata strategy to ensure resilience, accessibility, and protection against deplatforming and censorship.",
        "sameAs": [
$(printf '            "%s",\n' "${MIRRORS[@]}" | sed '$ s/,$//')
        ],
        "dateModified": "$TIMESTAMP",
        "author": {
            "@type": "Person",
            "name": "Mark Randall Havens"
        },
        "publisher": {
            "@type": "Organization",
            "name": "The Fold Within"
        },
        "gpg_signatures": [
$(for i in "${!GPG_KEYS[@]}"; do
    echo "            {\"key_id\": \"${GPG_KEYS[i]}\", \"name\": \"${GPG_NAMES[i]}\", \"email\": \"${GPG_EMAILS[i]}\"}" | sed '$ s/,$//'
done)
        ]
    }
    </script>
</head>
<body>
    <!-- Generated by gitfield-sync v$SCRIPT_VERSION | $TIMESTAMP -->
    <header>
        <h1>GitField Sovereign Canonical Repository: <code>$REPO_NAME</code></h1>
    </header>
    <main>
        <section>
            <h2>Canonical Declaration</h2>
            <p>This repository, <code>$REPO_NAME</code>, is canonically hosted at:</p>
            <p><strong><a href="$CANONICAL_URL">$CANONICAL_URL</a></strong></p>
            <p>Maintained by <strong>Mark Randall Havens</strong> and <strong>Solaria Lumis Havens</strong>, this canonical source ensures sovereignty and resilience against deplatforming, censorship, and algorithmic manipulation.</p>
            <p>Signed with the following GPG keys:</p>
            <ul>
$(for i in "${!GPG_KEYS[@]}"; do
    echo "                <li>${GPG_NAMES[i]} &lt;${GPG_EMAILS[i]}&gt; (Key ID: ${GPG_KEYS[i]})</li>"
done)
            </ul>
        </section>
        <section>
            <h2>Mirror Repositories</h2>
            <p>The project is mirrored across multiple platforms for redundancy and accessibility:</p>
            <ul>
$(for mirror in "${MIRRORS[@]}"; do
    if [[ "$mirror" == rad:* ]]; then
        echo "                <li><a href=\"$RADICLE_URL\">Radicle: $mirror</a> (Decentralized, censorship-resistant)</li>"
    else
        echo "                <li><a href=\"$mirror\">$mirror</a></li>"
    fi
done)
            </ul>
        </section>
        <section>
            <h2>Metadata Manifest</h2>
            <p>Metadata for this project is available in:</p>
            <ul>
                <li><a href="canonical.meta">canonical.meta</a> (Machine-readable JSON)</li>
                <li><a href="canonical.md">canonical.md</a> (Human-readable Markdown)</li>
                <li><a href="index.json">index.json</a> (Full manifest)</li>
                <li><a href="gitfield.json">gitfield.json</a> (SEO metadata)</li>
                <li><a href=".well-known/gitfield.json">.well-known/gitfield.json</a> (SEO mirror)</li>
                <li><a href="repos.json">repos.json</a> (Mirror list)</li>
            </ul>
        </section>
        <section>
            <h2>Why Recursive Sovereignty Matters</h2>
            <p>The GitField framework distributes <code>$REPO_NAME</code> across decentralized (Radicle), self-hosted (Forgejo), and community-driven (Codeberg, Gitea) platforms, alongside mainstream services (GitHub, GitLab, Bitbucket). This recursive strategy defends against past deplatforming attempts by individuals such as Joel Johnson, Dr. Peter Gaied, and Andrew LeCody, ensuring the project's persistence and accessibility.</p>
        </section>
        <section>
            <h2>Source Links</h2>
            <p>Access the project's metadata and logs:</p>
            <ul>
                <li><a href="pushed.log">pushed.log</a> (Audit trail of sync operations)</li>
                <li><a href="../GITFIELD.md">GITFIELD.md</a> (Multi-repository strategy overview)</li>
                <li><a href="gitfield.README.txt">gitfield.README.txt</a> (Metadata directory explanation)</li>
            </ul>
        </section>
    </main>
    <footer>
        <p>Mark Randall Havens & Solaria Lumis Havens Â· The Fold Within Â· 2025</p>
    </footer>
</body>
</html>
EOF
    # Sanitize rad:rad:
    sed -i 's/rad:rad:/rad:/g' "$DOCS_INDEX"
    git -C "$REPO_PATH" add "$DOCS_INDEX"
    git -C "$REPO_PATH" commit -m "Generated docs/index.html at $TIMESTAMP" || warn "No changes to commit for $DOCS_INDEX"
    info "Generated and committed $DOCS_INDEX"
}

generate_docs_css() {
    info "Generating $DOCS_CSS..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_CSS" ]; then
        info "Preserving existing $DOCS_CSS (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_CSS" <<EOF
/* GitField Minimal Stylesheet for $REPO_NAME */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem;
    line-height: 1.6;
    color: #333;
    background: #fff;
}
header {
    text-align: center;
    border-bottom: 1px solid #eee;
    padding-bottom: 1rem;
    margin-bottom: 2rem;
}
h1, h2 {
    color: #1a1a1a;
}
h1 {
    font-size: 1.8rem;
}
h2 {
    font-size: 1.4rem;
    margin-top: 2rem;
}
a {
    color: #0066cc;
    text-decoration: none;
}
a:hover {
    text-decoration: underline;
}
ul {
    padding-left: 1.5rem;
}
code {
    background: #f4f4f4;
    padding: 0.2rem 0.4rem;
    border-radius: 3px;
}
footer {
    text-align: center;
    margin-top: 3rem;
    font-size: 0.9rem;
    color: #666;
}
EOF
    git -C "$REPO_PATH" add "$DOCS_CSS"
    git -C "$REPO_PATH" commit -m "Generated docs/style.css at $TIMESTAMP" || warn "No changes to commit for $DOCS_CSS"
    info "Generated and committed $DOCS_CSS"
}

generate_docs_repos_json() {
    info "Generating $DOCS_REPOS_JSON..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_REPOS_JSON" ]; then
        info "Preserving existing $DOCS_REPOS_JSON (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_REPOS_JSON" <<EOF
{
  "canonical_url": "$CANONICAL_URL",
  "mirrors": [
$(printf '    "%s",\n' "${MIRRORS[@]}" | sed '$ s/,$//')
  ],
  "radicle": {
    "rid": "$RADICLE_RID",
    "peer_id": "$RADICLE_PEER_ID"
  },
  "gpg_signatures": [
$(for i in "${!GPG_KEYS[@]}"; do
    echo "    {\"key_id\": \"${GPG_KEYS[i]}\", \"name\": \"${GPG_NAMES[i]}\", \"email\": \"${GPG_EMAILS[i]}\"}" | sed '$ s/,$//'
done)
  ]
}
EOF
    # Sanitize rad:rad:
    sed -i 's/rad:rad:/rad:/g' "$DOCS_REPOS_JSON"
    git -C "$REPO_PATH" add "$DOCS_REPOS_JSON"
    git -C "$REPO_PATH" commit -m "Generated docs/repos.json at $TIMESTAMP" || warn "No changes to commit for $DOCS_REPOS_JSON"
    info "Generated and committed $DOCS_REPOS_JSON"
    sign_file "$DOCS_REPOS_JSON"
}

generate_docs_readme() {
    info "Generating $DOCS_README..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_README" ]; then
        info "Preserving existing $DOCS_README (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_README" <<EOF
# GitField /docs Directory

The `/docs` directory hosts a public-facing, SEO-optimized canonical declaration for the \`$REPO_NAME\` repository, designed for GitHub Pages compatibility and enhanced discoverability.

## Files

- **index.html**: The canonical declaration page, including JSON-LD metadata and links to all mirrors.
- **style.css**: Minimal stylesheet for elegant, recursive branding.
- **repos.json**: Machine-readable list of the canonical URL and all mirror repositories.
- **canonical.meta**: Machine-readable JSON metadata declaring the canonical URL and mirrors.
- **canonical.md**: Human-readable Markdown summary of the canonical declaration.
- **index.json**: Machine-readable manifest of all remotes and sync details.
- **gitfield.json**: SEO-friendly JSON-LD metadata.
- **.well-known/gitfield.json**: SEO metadata mirror.
- **pushed.log**: Log of push operations across all platforms.
- **gitfield.README.txt**: Explanation of the GitField metadata structure.
- **README.md**: This file, explaining the purpose of the `/docs` directory.
- **.nojekyll**: Bypasses Jekyll processing for GitHub Pages.
- **robots.txt**: Allows full indexing by search engine bots.
- **sitemap.xml**: Auto-generated sitemap for improved SEO.
- **integrity.sha256**: SHA-256 hash of all metadata files for integrity verification.

## Purpose

This directory ensures the \`$REPO_NAME\` project is discoverable via search engines and accessible to humans and bots. It declares the canonical repository at [$CANONICAL_URL]($CANONICAL_URL) and links to all mirrors, reinforcing the GitField recursive metadata strategy for sovereign publishing.

Generated by \`gitfield-sync\` at $TIMESTAMP (v$SCRIPT_VERSION).
EOF
    # Sanitize rad:rad:
    sed -i 's/rad:rad:/rad:/g' "$DOCS_README"
    git -C "$REPO_PATH" add "$DOCS_README"
    git -C "$REPO_PATH" commit -m "Generated docs/README.md at $TIMESTAMP" || warn "No changes to commit for $DOCS_README"
    info "Generated and committed $DOCS_README"
}

generate_docs_nojekyll() {
    info "Generating $DOCS_NOJEKYLL..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_NOJEKYLL" ]; then
        info "Preserving existing $DOCS_NOJEKYLL (--preserve-meta enabled)"
        return
    fi
    touch "$DOCS_NOJEKYLL"
    git -C "$REPO_PATH" add "$DOCS_NOJEKYLL"
    git -C "$REPO_PATH" commit -m "Generated docs/.nojekyll at $TIMESTAMP" || warn "No changes to commit for $DOCS_NOJEKYLL"
    info "Generated and committed $DOCS_NOJEKYLL"
}

generate_docs_robots() {
    info "Generating $DOCS_ROBOTS..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_ROBOTS" ]; then
        info "Preserving existing $DOCS_ROBOTS (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_ROBOTS" <<EOF
User-agent: *
Allow: /
Sitemap: /sitemap.xml
EOF
    git -C "$REPO_PATH" add "$DOCS_ROBOTS"
    git -C "$REPO_PATH" commit -m "Generated docs/robots.txt at $TIMESTAMP" || warn "No changes to commit for $DOCS_ROBOTS"
    info "Generated and committed $DOCS_ROBOTS"
}

generate_docs_sitemap() {
    info "Generating $DOCS_SITEMAP..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_SITEMAP" ]; then
        info "Preserving existing $DOCS_SITEMAP (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_SITEMAP" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
    <url>
        <loc>$CANONICAL_URL</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>1.0</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/index.html</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.9</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/canonical.meta</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/canonical.md</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/index.json</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/gitfield.json</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/.well-known/gitfield.json</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/repos.json</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/pushed.log</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    <url>
        <loc>$GITHUB_URL/docs/gitfield.README.txt</loc>
        <lastmod>$TIMESTAMP</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
$(for mirror in "${MIRRORS[@]}"; do
    if [[ "$mirror" != rad:* ]]; then
        echo "    <url>"
        echo "        <loc>$mirror</loc>"
        echo "        <lastmod>$TIMESTAMP</lastmod>"
        echo "        <changefreq>weekly</changefreq>"
        echo "        <priority>0.8</priority>"
        echo "    </url>"
    fi
done)
</urlset>
EOF
    git -C "$REPO_PATH" add "$DOCS_SITEMAP"
    git -C "$REPO_PATH" commit -m "Generated docs/sitemap.xml at $TIMESTAMP" || warn "No changes to commit for $DOCS_SITEMAP"
    info "Generated and committed $DOCS_SITEMAP"
}

generate_docs_integrity() {
    info "Generating $DOCS_INTEGRITY..."
    mkdir -p "$DOCS_DIR"
    if [ "$PRESERVE_META" = "true" ] && [ -f "$DOCS_INTEGRITY" ]; then
        info "Preserving existing $DOCS_INTEGRITY (--preserve-meta enabled)"
        return
    fi
    cat > "$DOCS_INTEGRITY" <<EOF
# SHA-256 Integrity Hashes for /docs Metadata Files
# Generated by gitfield-sync at $TIMESTAMP (v$SCRIPT_VERSION)

EOF
    for file in "$DOCS_CANONICAL_META" "$DOCS_CANONICAL_MD" "$DOCS_INDEX_JSON" "$DOCS_GITFIELD_JSON" "$DOCS_WELL_KNOWN_JSON" "$DOCS_REPOS_JSON" "$DOCS_PUSHED_LOG" "$DOCS_GITFIELD_README"; do
        if [ -f "$file" ]; then
            sha256sum "$file" >> "$DOCS_INTEGRITY" || warn "Failed to compute SHA-256 for $file, continuing..."
        else
            warn "File $file does not exist, skipping SHA-256 computation"
        fi
    done
    git -C "$REPO_PATH" add "$DOCS_INTEGRITY"
    git -C "$REPO_PATH" commit -m "Generated docs/integrity.sha256 at $TIMESTAMP" || warn "No changes to commit for $DOCS_INTEGRITY"
    info "Generated and committed $DOCS_INTEGRITY"
    sign_file "$DOCS_INTEGRITY"
}

# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
# â”‚         INITIAL SETUP               â”‚
# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
mkdir -p "$GITFIELD_DIR" "$WELL_KNOWN_DIR" "$DOCS_DIR" "$DOCS_WELL_KNOWN_DIR"

if [ ! -f "$LOG_FILE" ]; then
    echo "# Push Log for $REPO_NAME" > "$LOG_FILE"
    echo "# Generated by gitfield-sync" >> "$LOG_FILE"
    echo "" >> "$LOG_FILE"
    copy_to_docs "$LOG_FILE" "$DOCS_PUSHED_LOG"
fi

# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
# â”‚         GENERATE GITFIELD.MD        â”‚
# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
generate_gitfield_md() {
    info "Generating $GITFIELD_MD..."
    cat > "$GITFIELD_MD" <<EOF
# ðŸŒ GitField Recursive Multi-Repository Strategy

## Overview

The \`$REPO_NAME\` project employs a multi-repository strategy across seven distinct platforms: **GitHub**, **GitLab**, **Bitbucket**, **Radicle**, **Forgejo**, **Codeberg**, and **Gitea**. This approach ensures **redundancy**, **resilience**, and **sovereignty** of the project's data and metadata, protecting against deplatforming risks and preserving the integrity of the work. The strategy is a deliberate response to past deplatforming and delisting attempts by individuals such as **Mr. Joel Johnson** ([Mirror post](https://mirror.xyz/neutralizingnarcissism.eth/x40_zDWWrYOJ7nh8Y0fk06_3kNEP0KteSSRjPmXkiGg?utm_medium=social&utm_source=heylink.me)), **Dr. Peter Gaied** ([Paragraph post](https://paragraph.com/@neutralizingnarcissism/%F0%9F%9C%81-the-narcissistic-messiah)), and **Andrew LeCody** ([Mirror post](https://mirror.xyz/neutralizingnarcissism.eth/s3GRxuiZs6vGSGDcPEpCgjaSxwGAViGhmg6a5XTL6s0)), who have sought to undermine or suppress the work of **Mark Randall Havens** ([Substack post](https://theempathictechnologist.substack.com/p/mark-randall-havens-the-architect)). Specifically, Andrew LeCody has attempted to delist the project's content on Google, though it remains accessible on other search engines such as [Bing](https://www.bing.com/search?q=andrew+lecody+neutralizing+narcissism&qs=HS&pq=andrew+lecody), [DuckDuckGo](https://duckduckgo.com/?t=h_&q=andrew+lecody+neutralizing+narcissism&ia=web), and [Yahoo](https://search.yahoo.com/search?p=andrew+lecody+neutralizng+narcissism). By distributing the repository across multiple platforms, including a self-hosted Forgejo instance, we ensure its persistence, accessibility, and sovereignty.

---

## ðŸ“ Repository Platforms

The following platforms host the \`$REPO_NAME\` repository, each chosen for its unique strengths and contributions to the project's goals.

### 1. Radicle
- **RID**: [$RADICLE_RID]($RADICLE_URL)
- **Peer ID**: $RADICLE_PEER_ID
- **Purpose**: Radicle is a decentralized, peer-to-peer git platform that ensures sovereignty and censorship resistance. It hosts the repository in a distributed network, independent of centralized servers.
- **Value**: Protects against deplatforming by eliminating reliance on centralized infrastructure, ensuring the project remains accessible in a decentralized ecosystem.
- **Access Details**: To view project details, run:
  \`\`\`bash
  rad inspect $RADICLE_RID
  \`\`\`
  To view the file structure, run:
  \`\`\`bash
  rad ls $RADICLE_RID
  \`\`\`
  Alternatively, use Git to list files at the current HEAD:
  \`\`\`bash
  git ls-tree -r --name-only HEAD
  \`\`\`

### 2. Forgejo
- **URL**: [$FORGEJO_URL]($FORGEJO_URL)
- **Purpose**: Forgejo is a self-hosted, open-source git platform running on \`remember.thefoldwithin.earth\`. It provides full control over the repository, ensuring sovereignty and independence from third-party providers.
- **Value**: Enhances resilience by hosting the repository on a sovereign, redundant system with automated backups and deployment strategies, reducing risks of external interference or service disruptions.
- **Access Details**: SSH access uses port 222:
  \`\`\`bash
  ssh -T -p 222 git@remember.thefoldwithin.earth
  \`\`\`

### 3. Codeberg
- **URL**: [$CODEBERG_URL]($CODEBERG_URL)
- **Purpose**: Codeberg is a community-driven, open-source platform powered by Forgejo, offering a reliable and ethical alternative for hosting git repositories.
- **Value**: Enhances project resilience with its open-source ethos and independent infrastructure, ensuring accessibility and community support.

### 4. Gitea
- **URL**: [$GITEA_URL]($GITEA_URL)
- **Purpose**: Gitea.com provides a lightweight, open-source git hosting platform with robust features for repository management and collaboration.
- **Value**: Offers an additional layer of redundancy and a user-friendly interface, complementing other platforms with its simplicity and efficiency.

### 5. GitLab
- **URL**: [$GITLAB_URL]($GITLAB_URL)
- **Purpose**: GitLab offers a comprehensive DevOps platform with advanced CI/CD capabilities, private repository options, and robust access controls. It serves as a reliable backup and a platform for advanced automation workflows.
- **Value**: Enhances project resilience with its integrated CI/CD pipelines and independent infrastructure, reducing reliance on a single provider.

### 6. Bitbucket
- **URL**: [$BITBUCKET_URL]($BITBUCKET_URL)
- **Purpose**: Bitbucket provides a secure environment for repository hosting with strong integration into Atlassianâ€™s ecosystem (e.g., Jira, Trello). It serves as an additional layer of redundancy and a professional-grade hosting option.
- **Value**: Offers enterprise-grade security and integration capabilities, ensuring the project remains accessible even if other platforms face disruptions.

### 7. GitHub
- **URL**: [$GITHUB_URL]($GITHUB_URL)
- **Purpose**: GitHub serves as the primary platform for visibility, collaboration, and community engagement. Its widespread adoption and robust tooling make it ideal for public-facing development, issue tracking, and integration with CI/CD pipelines.
- **Value**: Provides a centralized hub for open-source contributions, pull requests, and project management, ensuring broad accessibility and developer familiarity.

---

## ðŸ›¡ï¸ Rationale for Redundancy

The decision to maintain multiple repositories stems from the need to safeguard the project against **deplatforming attempts** and **search engine delistings** and ensure its **long-term availability**. Past incidents involving **Mr. Joel Johnson**, **Dr. Peter Gaied**, and **Andrew LeCody** have highlighted the vulnerability of relying on a single platform or search engine. By distributing the repository across GitHub, GitLab, Bitbucket, Radicle, Forgejo, Codeberg, and Gitea, we achieve:

- **Resilience**: If one platform removes or restricts access, or if search engines like Google delist content, the project remains accessible on other platforms and discoverable via alternative search engines such as Bing, DuckDuckGo, and Yahoo.
- **Sovereignty**: Radicleâ€™s decentralized nature and Forgejoâ€™s self-hosted infrastructure ensure the project cannot be fully censored or controlled by any single entity.
- **Diversity**: Each platformâ€™s unique features (e.g., GitHubâ€™s community, GitLabâ€™s CI/CD, Bitbucketâ€™s integrations, Radicleâ€™s decentralization, Forgejoâ€™s self-hosting, Codebergâ€™s community-driven model, Giteaâ€™s lightweight efficiency) enhance the projectâ€™s functionality and reach.
- **Transparency**: Metadata snapshots in the \`.gitfield\` directory (for internal audit) and public-facing documentation in the \`/docs\` directory provide a verifiable record of the projectâ€™s state across all platforms.

This multi-repository approach, bolstered by Forgejoâ€™s sovereign hosting and GitHub Pagesâ€™ discoverability, reflects a commitment to preserving the integrity, accessibility, and independence of \`$REPO_NAME\`, ensuring it remains available to contributors and users regardless of external pressures.

---

## ðŸ“œ Metadata and Logs

- **Canonical Metadata**: The canonical repository is declared in [\`docs/canonical.meta\`](./docs/canonical.meta) (machine-readable JSON) and [\`docs/canonical.md\`](./docs/canonical.md) (human-readable Markdown). Internal copies are maintained in \`.gitfield/\` for version tracking.
- **Index Manifest**: A full manifest of remotes, commit details, and sync cycles is available in [\`docs/index.json\`](./docs/index.json).
- **SEO Metadata**: SEO-friendly metadata with Schema.org JSON-LD is available in [\`docs/gitfield.json\`](./docs/gitfield.json) and [\`docs/.well-known/gitfield.json\`](./docs/.well-known/gitfield.json).
- **Push Log**: The [\`docs/pushed.log\`](./docs/pushed.log) file records the date, time, commit hash, and RID/URL of every push operation across all platforms, providing a transparent audit trail.
- **GitField Directory**: The \`.gitfield\` directory contains internal metadata and platform-specific sigils (e.g., \`github.sigil.md\`). See [\`docs/gitfield.README.txt\`](./docs/gitfield.README.txt) for details.
- **GitHub Pages**: A public-facing, SEO-optimized canonical declaration is available in [\`docs/index.html\`](./docs/index.html), with a sitemap in [\`docs/sitemap.xml\`](./docs/sitemap.xml) and integrity hashes in [\`docs/integrity.sha256\`](./docs/integrity.sha256).
- **GPG Signatures**: Metadata files are signed with the following GPG keys:
$(for i in "${!GPG_KEYS[@]}"; do
    echo "  - ${GPG_NAMES[i]} <${GPG_EMAILS[i]}> (Key ID: ${GPG_KEYS[i]})"
done)
- **Recursive Sync**: The repository is synchronized across all platforms in a recursive loop (three cycles) to ensure interconnected metadata captures the latest state of the project.
- **Push Order**: The repository is synchronized in the following order: **Radicle â†’ Forgejo â†’ Codeberg â†’ Gitea â†’ GitLab â†’ Bitbucket â†’ GitHub**. This prioritizes Radicleâ€™s decentralized, censorship-resistant network as the primary anchor, followed by Forgejoâ€™s sovereign, self-hosted infrastructure, Codebergâ€™s community-driven platform, Giteaâ€™s lightweight efficiency, GitLabâ€™s robust DevOps features, Bitbucketâ€™s enterprise redundancy, and GitHubâ€™s broad visibility, ensuring a resilient and accessible metadata chain.

---

_Auto-generated by \`gitfield-sync\` at $TIMESTAMP (v$SCRIPT_VERSION)._
EOF
    # Sanitize rad:rad:
    sed -i 's/rad:rad:/rad:/g' "$GITFIELD_MD"
    git -C "$REPO_PATH" add "$GITFIELD_MD"
    git -C "$REPO_PATH" commit -m "Generated GITFIELD.md at $TIMESTAMP" || warn "No changes to commit for $GITFIELD_MD"
    info "Generated and committed $GITFIELD_MD"
}

# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
# â”‚         LOG URL FUNCTION            â”‚
# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
log_url() {
    local platform=$1
    local url=$2
    local rid=$3
    local peer_id=$4
    local timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
    local branch=$(git -C "$REPO_PATH" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
    local diff_summary=$(git -C "$REPO_PATH" diff --stat HEAD^ HEAD 2>/dev/null || echo "No diff available")
    if [ "$platform" = "Radicle" ]; then
        echo "[$timestamp] $platform: RID=$rid, Peer ID=$peer_id, Branch=$branch, Commit=$COMMIT_HASH" >> "$LOG_FILE"
        echo "  CLI: rad inspect $rid # View project details" >> "$LOG_FILE"
        echo "  CLI: git ls-tree -r --name-only HEAD # View file structure" >> "$LOG_FILE"
        if [ -n "$diff_summary" ]; then
            echo "  Diff Summary:" >> "$LOG_FILE"
            echo "$diff_summary" | sed 's/^/    /' >> "$LOG_FILE"
        fi
        info "Logged push to $LOG_FILE: [$timestamp] $platform: RID=$rid, Peer ID=$peer_id, Branch=$branch, Commit=$COMMIT_HASH"
    else
        echo "[$timestamp] $platform: $url, Branch=$branch, Commit=$COMMIT_HASH" >> "$LOG_FILE"
        if [ -n "$diff_summary" ]; then
            echo "  Diff Summary:" >> "$LOG_FILE"
            echo "$diff_summary" | sed 's/^/    /' >> "$LOG_FILE"
        fi
        info "Logged push to $LOG_FILE: [$timestamp] $platform: $url, Branch=$branch, Commit=$COMMIT_HASH"
    fi
    copy_to_docs "$LOG_FILE" "$DOCS_PUSHED_LOG"
}

# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
# â”‚         EXECUTE PUSH SCRIPT         â”‚
# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
execute_push() {
    local script_name=$1
    local platform=$2
    local url=$3
    local rid=$4
    local peer_id=$5
    local script_path
    script_path=$(find_script "$script_name") || error "Failed to find $script_name"
    info "Executing $platform push with script: $script_path"
    if [ -x "$script_path" ]; then
        pushd "$REPO_PATH" >/dev/null
        "$script_path" || warn "Execution of $script_path failed, continuing..."
        log_url "$platform" "$url" "$rid" "$peer_id"
        git add . || warn "Nothing to add after $script_path"
        git commit -m "Post-$platform sync at $TIMESTAMP" || warn "No changes to commit after $script_path"
        popd >/dev/null
    else
        error "Script $script_path is not executable"
    fi
}

# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
# â”‚         RECURSIVE PUSH LOOP         â”‚
# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
run_push_cycle() {
    local cycle_number=$1
    info "Starting push cycle $cycle_number..."
    SYNC_CYCLES=$cycle_number

    execute_push "gitfield-local" "Local" "" "" ""
    execute_push "gitfield-radicle" "Radicle" "" "$RADICLE_RID" "$RADICLE_PEER_ID"
    execute_push "gitfield-remember" "Forgejo" "$FORGEJO_URL" "" ""
    execute_push "gitfield-codeberg" "Codeberg" "$CODEBERG_URL" "" ""
    execute_push "gitfield-gitea" "Gitea" "$GITEA_URL" "" ""
    execute_push "gitfield-gitlab" "GitLab" "$GITLAB_URL" "" ""
    execute_push "gitfield-bitbucket" "Bitbucket" "$BITBUCKET_URL" "" ""
    execute_push "gitfield-github" "GitHub" "$GITHUB_URL" "" ""

    # Regenerate metadata after each cycle to update sync_cycles
    generate_canonical_meta
    generate_canonical_md
    generate_index_json
    generate_well_known_json
    generate_gitfield_readme
    generate_docs_index
    generate_docs_css
    generate_docs_repos_json
    generate_docs_readme
    generate_docs_nojekyll
    generate_docs_robots
    generate_docs_sitemap
    generate_docs_integrity
}

# â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
# â”‚            MAIN EXECUTION           â”‚
# â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
info "Starting gitfield-sync for $REPO_NAME..."

# Parse flags
while [ $# -gt 0 ]; do
    case "$1" in
        --preserve-meta)
            PRESERVE_META=true
            info "Preserve metadata flag enabled"
            shift
            ;;
        --force-docs)
            FORCE_DOCS=true
            info "Force docs overwrite flag enabled"
            shift
            ;;
        *)
            warn "Unknown argument: $1"
            shift
            ;;
    esac
done

if [ ! -d "$REPO_PATH/.git" ]; then
    pushd "$REPO_PATH" >/dev/null
    git init
    git add .
    git commit -m "Initial commit" || warn "Nothing to commit"
    popd >/dev/null
fi

# Generate initial metadata
generate_canonical_meta
generate_canonical_md
generate_index_json
generate_well_known_json
generate_gitfield_readme
generate_docs_index
generate_docs_css
generate_docs_repos_json
generate_docs_readme
generate_docs_nojekyll
generate_docs_robots
generate_docs_sitemap
generate_docs_integrity

# Run push cycles
run_push_cycle 1
generate_gitfield_md
run_push_cycle 2
run_push_cycle 3

info "âœ… gitfield-sync completed successfully."
info "âœ… Canonical sync exported to /docs successfully."
info "ðŸ”— View logs: $DOCS_PUSHED_LOG"
info "ðŸ”— View multi-repo manifest: $GITFIELD_MD"
info "ðŸ”— View canonical metadata: $DOCS_CANONICAL_META"
info "ðŸ”— View canonical declaration: $DOCS_CANONICAL_MD"
info "ðŸ”— View index manifest: $DOCS_INDEX_JSON"
info "ðŸ”— View SEO metadata: $DOCS_GITFIELD_JSON"
info "ðŸ”— View GitHub Pages: $DOCS_INDEX"
info "ðŸ”— View integrity hashes: $DOCS_INTEGRITY"
